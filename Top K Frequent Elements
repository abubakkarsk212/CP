#include <bits/stdc++.h>
class Solution {
public:
    //T.c = O(nlogk)
     vector<int> usingheapHash(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        for(int i =0; i <nums.size();i++) {
            mp[nums[i]]++;
        }
        vector<int> ans;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        for (auto i : mp){
            pq.push(make_pair(i.second,i.first));
            if(pq.size()>k){
                pq.pop();
            }
        }
        while(pq.size()!=0){
            ans.push_back(pq.top().second);
            pq.pop();
        }
       return ans; 
    }
    //takes T.c = (NlogN), s.c = O(k)
    vector<int> brute(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        nums.push_back(0);
        vector<int> ans;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        int count = 1;
        for(int i =0; i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                count++;
            }
            if(nums[i]!=nums[i+1]){
                pair<int,int> pp;
                pp.first = count;
                pp.second = nums[i];
                pq.push(pp);
                if(pq.size()>k){
                    pq.pop();
                }
                count =1;
            }
        }
        while(pq.size()!=0){
            ans.push_back(pq.top().second);
            pq.pop();
        }
       return ans; 
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        return usingheapHash(nums,k);
    }
};
