Q:


/*
	Note:
	To get all the test cases accepted, make recursive calls in following order: Top, Down, Left, Right.
	This means that if the current cell is (x, y), then order of calls should be: top cell (x-1, y), 
	down cell (x+1, y), left cell (x, y-1) and right cell (x, y+1).
*/
#include<bits/stdc++.h>
using namespace std;
void helper(vector<vector<int>> &m,int n,vector<vector<bool>> &visited,vector<vector<int>> &board,int c,int r){
        if( r == n-1 && c == n-1){
            board[r][c] = 1;
            for(int i =0; i<n;i++){
                for(int j =0;j<n;j++){
                    cout<<board[i][j]<<" ";
                }
            }
            board[r][c] = 0;
            cout<<endl;
            return;
        }
        int dx[] = {-1,0,1,0};
        int dy[] = {0,1,0,-1};
        for(int i =0; i<4;i++){
            int nx = dx[i]+r;
            int ny = dy[i]+c;
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                if(m[nx][ny] == 1 && visited[nx][ny] == false){
                   
                    visited[r][c] = true;
                    board[r][c] = 1;
                    helper(m,n,visited,board,ny,nx);
                    board[r][c] = 0;
                    visited[r][c] = false;
                }
            }
        }
    }
    void findPath(vector<vector<int>> &m, int n) {
        // Your code goes here
        if(m[0][0] == 0){
            return;
        }
         
         vector<vector<int>> board(n,vector<int>(n,0));
         vector<vector<bool>> visited(n,vector<bool>(n,false));
         helper(m,n,visited,board,0,0);
    
    }
int main() {
    int n;
    cin >> n;
    vector<vector<int>> m(n,vector<int>(n,0));
    for(int i =0; i<n;i++){
        for(int j =0; j<n;j++){
            int g;
            cin>>g;
            m[i][j] = g;
        }
    }
    findPath(m,n);
	// Write your code here
	return 0;
}
