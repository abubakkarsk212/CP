#include <iostream>
using namespace std;

bool hasPath(int **mat,int n,int v1,bool *visited,int v2){
    if(mat[v1][v2] == 1){
        return true;
    }
    visited[v1]=true;
    //Now we need to print its adjacent element
    for(int i =0; i<n;i++){
    // here the issue is if 0 - 1- 2 it will go to 1 and 1 adjacent is 0 again go
    //to 0 and it will loop
    if(i == v1){
    continue;
    }
    if(mat[v1][i] == 1){
    if(visited[i]){
    continue;
    }
    bool a = hasPath(mat,n,i,visited,v2);
        if(a)
         return a;
    }
    }
    return false;
}

//For disconnected
// bool DFS(int **mat,int n,int v1,int v2){
//     bool *visited = new bool[n];
//     for(int i =0; i<n;i++){
//     visited[i] = false;
//     }
//     //checking the visited array to check if any disconnected component is left
//     for(int i =v1; i<n;i++){
//     if(!visited[i]){
//     bool a =hasPath(mat,n,i,visited);
//         if(a) return true;
//     }
//     }
//     delete [] visited;
//     return false;
// }

int main() {
    // Write your code here
     // Write your code here
    int n,e;
	cin>>n>>e;

//Now we need a 2d matrix to store
	int **mat = new int*[n];
    for(int i =0; i<n;i++){
        mat[i] = new int[n];
        //As garbage fill with 0-means no edge
        for(int j =0; j<n;j++){
        	mat[i][j] = 0;
       	 }

    }
    //for edges
    for(int i =0; i<e;i++){
        int f,s;
        cin>>f>>s;
        mat[f][s] = 1;
        mat[s][f] = 1;

    }
    int v1,v2;
	cin>>v1>>v2;
     bool *visited = new bool[n];
    for(int i =0; i<n;i++){
    visited[i] = false;
    }
    bool a =hasPath(mat,n,v1,visited,v2);
    if(a){
       cout<< "true";
}else{
       cout<< "false";
        
    }  
    }
   
